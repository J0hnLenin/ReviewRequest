# ReviewRequest

[![Tests](https://github.com/J0hnLenin/ReviewRequest/actions/workflows/coverage.yml/badge.svg)](https://github.com/J0hnLenin/ReviewRequest/actions/workflows/coverage.yml)
[![Coverage Status](https://coveralls.io/repos/github/J0hnLenin/ReviewRequest/badge.svg?branch=main)](https://coveralls.io/github/J0hnLenin/ReviewRequest)

![Go](https://img.shields.io/badge/Go-1.23+-00ADD8?style=for-the-badge&logo=go)
![PostgreSQL](https://img.shields.io/badge/PostgreSQL-4169E1?style=for-the-badge&logo=postgresql&logoColor=white)
![Docker](https://img.shields.io/badge/Docker-2496ED?style=for-the-badge&logo=docker&logoColor=white)

![Testify](https://img.shields.io/badge/-Testify-00ADD8?logo=go&logoColor=white)
![PgAdmin](https://img.shields.io/badge/-PgAdmin-4169E1?logo=postgresql&logoColor=white)
![Docker Compose](https://img.shields.io/badge/-Docker%20Compose-2496ED?logo=docker&logoColor=white)
![GitHub Actions](https://img.shields.io/badge/-GitHub%20Actions-2088FF?logo=github-actions&logoColor=white)
![Postman](https://img.shields.io/badge/-Postman-FF6C37?logo=postman&logoColor=white)
![Coveralls](https://img.shields.io/badge/-Coveralls-3F5767?logo=coveralls&logoColor=white)

Сервис для автоматического назначения членов команы на код-ревью пул-реквестов

# Установка и запуск

Необходимые компоненты: git, docker

1. Клонировать репозиторий

```
git clone https://github.com/J0hnLenin/ReviewRequest
cd ./ReviewRequest
```

2. При необходимости поменять секреты в файле .env, но этот шаг необязательный
3. Собрать проект

```
docker compose up -d
```

4. После этого можно проверить работу сервиса:  
   :8080 - backend приложения  
   Post:5430 - postgres  
   Port:5050 - pgAdmin  
  
При этом порт postgres открыт наружу для тестов и отладки, в продакшн-реализации нужно его закрыть. Если нет необходимости в pgAdmin, его тоже можно убрать.

# Вопросы и принятые решения

## Возможность пользователя состоять в множестве команд одновременно

Можно поступить двумя способами:

1. поддерживать логику 1 пользователь -> множесто команд
2. придерживаться логики 1 пользователь -> 1 команда

Так как операция создания пулл-реквеста требует назначения ревьюеров из команды пользователя, то в случае первого сценария будет неясно из какой именно команды назначать ревьюеров. Поэтому я принял решение пойти по второму сценарию.

Если сервису потребуется расширение и поддержка множества команд для одного пользователя, то можно будет создать новую сущность, которая ставится в соответствие сотруднику и агрегирует несколько экземпляров сущности пользователь.

## Вопрос о хранении данных

Можно поступить следующими способами:

1. хранить данные ненормализовано в jsonb
2. хранить данные частично нормализовано
3. хранить данные полностью нормализовано

В варианте 1 есть преимущество того, что нет необходимости произвоить множество джойнов всех таблиц, из-за чего операции выбора будут достаточно быстрые. Однако индексы в нормализованой БД решают эти проблемы, тем более сложных условий на JOIN мы не накладываем.

Между вариантами 2 и 3 я вижу следующую разницу. Можно вынести отношение PR - reviewers в отдельную таблицу, или хранить в виде массива postgres. Я принял решение хранить в виде массива, потому что нам всегда необходимо получать информацию о ревьюерах, когда мы работаем с пулл-реквестом. А также количество ревьюеров ограничено 2, т.е. размер базы в случае варианта 2 не будет сильно разрастаться, по сравнению с вариантом 3.

## /health

В документации API не указан эндпоинт для проверки сервиса, поэтому я решил добавить эндпоинт  
/health
с ответом формата json:
{  
 "status": "healthy"  
}

## Вопрос об ошибке

В документации API явно не указано, какую ошибку должен возвращать запрос переназначения ревьюера, если ревьюер с данным ID не существует, и при этом PR уже находится в статусе MERGED. Предполагаю, что ошибка должна быть 404 Not found, т.к. сначала необходимо проверить существование сущностей по данным идентификаторам, а затем проверять условия бизнес-логики. Поэтому мой сервис возвращает 404.

# Предложения по улудшению

Если в будущем возникнут проблемы с производительностью данного сервиса (расширится объём базы, увеличиться количество пользователей), то можно будет применить шардирование по командам. Разные команды разбить по разным шардам так, чтобы каждая команда находилась в одном шарде с юзерами и PR, относящейся к ней.

Также хорошо бы хранить информацию об открытых PR и в postgres, и в redis для более быстрого доступа к наиболее важным данным. Считаем что к открытому PR выполняется больше запросов, чем к закрытому.

# Тесты

## Unit-тесты

Написал юнит тесты для сервисного слоя. Не покрыт апи и код, выполняющий запросы в postgres, однако этот код я протестировал во время E2E-тестов. 

Запуск тестов:
```
go test -cover ./service
```
## E2E-тестирование

Для тестирования использовал postman. Проверил все запросы из спецификации api (/docs/openapi.yml).
Всего вышло 70 тест-кейсов. Коллекция для импорта в postman находится в папке /tests. Проверил как позитивные так и негативные сценарии.

![tests_1](./docs/E2E_1.png)
![tests_2](./docs/E2E_2.png)
